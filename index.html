<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sneaky Snake</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #1e3c72, #2a5298);
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        touch-action: manipulation;
        user-select: none;
      }

      .game-container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      h1 {
        color: white;
        text-align: center;
        margin-bottom: 20px;
        font-size: 2.5rem;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      .game-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        color: white;
        font-size: 1.4rem;
        font-weight: bold;
      }

      .score {
        background: rgba(46, 204, 113, 0.8);
        padding: 10px 20px;
        border-radius: 25px;
        box-shadow: 0 4px 15px rgba(46, 204, 113, 0.3);
      }

      .status {
        background: rgba(52, 152, 219, 0.8);
        padding: 10px 20px;
        border-radius: 25px;
        box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
      }

      #gameCanvas {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-radius: 15px;
        background: #0a0a0a;
        display: block;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
        max-width: 100%;
        max-height: 80vh;
      }

      @media (max-width: 768px) {
        .game-container {
          padding: 20px;
          margin: 10px;
        }

        h1 {
          font-size: 2rem;
        }

        .game-info {
          font-size: 1.2rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <h1>üêç Sneaky Snake</h1>
      <div class="game-info">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="status" id="status">Speed: 0%</div>
      </div>
      <canvas id="gameCanvas" width="600" height="600"></canvas>
    </div>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreElement = document.getElementById("score");
      const statusElement = document.getElementById("status");

      // Responsive game settings
      let canvasSize;
      let gridSize;
      let tileCount;

      // Performance optimization: cache interpolated snake positions
      let cachedInterpolatedSnake = [];
      let lastMoveProgress = -1;

      function calculateGameDimensions() {
        // Get viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Calculate available space (accounting for UI elements)
        const availableWidth = Math.min(viewportWidth - 40, 800); // Max 800px
        const availableHeight = Math.min(viewportHeight - 200, 800); // Leave space for UI

        // Use the smaller dimension to keep it square
        canvasSize = Math.min(availableWidth, availableHeight);

        // Ensure minimum size for playability
        canvasSize = Math.max(canvasSize, 300);

        // Calculate grid size for good gameplay (aim for 15-25 tiles per side)
        gridSize = Math.floor(canvasSize / 20); // 20 tiles per side
        tileCount = Math.floor(canvasSize / gridSize);

        // Adjust canvas to exact grid multiple
        canvasSize = tileCount * gridSize;

        // Update canvas dimensions
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        canvas.style.width = canvasSize + "px";
        canvas.style.height = canvasSize + "px";
      }

      let snake = [{ x: 10, y: 10 }];
      let prevSnake = [{ x: 10, y: 10 }];
      let food = {};
      let walls = [];

      // dx and dy and the delta of the current tick
      let dx = 0;
      let dy = 0;
      // dx_next and dy_next are the delta for the next frame
      // they will only be valud on the next tick but can change
      // freely during the current one
      let dx_next = 0;
      let dy_next = 0;
      let score = 0;
      let gameRunning = true;
      let moveProgress = 1;
      let lastMoveTime = 0;
      let baseInterval = 120;
      let minInterval = 60;

      function initializeSnakePosition() {
        const centerX = Math.floor(tileCount / 2);
        const centerY = Math.floor(tileCount / 2);
        snake = [{ x: centerX, y: centerY }];
        prevSnake = [{ x: centerX, y: centerY }];
        dx = 0;
        dy = 0;
        dx_next = 0;
        dy_next = 0;
      }

      // Touch handling for swipes
      let startX = 0;
      let startY = 0;
      let endX = 0;
      let endY = 0;

      function randomTilePosition() {
        return Math.floor(Math.random() * tileCount);
      }

      function isPositionOccupied(x, y) {
        // Check if position is occupied by snake
        for (let segment of snake) {
          if (segment.x === x && segment.y === y) {
            return true;
          }
        }
        // Check if position is occupied by walls
        for (let wall of walls) {
          if (wall.x === x && wall.y === y) {
            return true;
          }
        }
        // Check if position is occupied by food
        if (food.x === x && food.y === y) {
          return true;
        }
        return false;
      }

      function generateWalls() {
        walls = [];
        const numWalls = Math.max(4, Math.floor((tileCount * tileCount) / 80)); // Scale walls with board size

        for (let i = 0; i < numWalls; i++) {
          let wallX, wallY;
          let attempts = 0;

          do {
            wallX = randomTilePosition();
            wallY = randomTilePosition();
            attempts++;
          } while (isPositionOccupied(wallX, wallY) && attempts < 50);

          // Make sure wall is not too close to snake starting position
          const centerX = Math.floor(tileCount / 2);
          const centerY = Math.floor(tileCount / 2);
          if (Math.abs(wallX - centerX) > 2 || Math.abs(wallY - centerY) > 2) {
            walls.push({ x: wallX, y: wallY });
          }
        }
      }

      function randomFoodPosition() {
        let foodX, foodY;
        let attempts = 0;

        do {
          foodX = randomTilePosition();
          foodY = randomTilePosition();
          attempts++;
        } while (isPositionOccupied(foodX, foodY) && attempts < 50);

        food = { x: foodX, y: foodY };
      }

      function getCurrentMoveInterval() {
        // Speed up by 4ms for each apple eaten (every 10 points)
        const speedIncrease = Math.floor(score / 10) * 4;
        return Math.max(minInterval, baseInterval - speedIncrease);
      }

      function lerp(start, end, progress) {
        // Use smooth linear interpolation
        return start + (end - start) * progress;
      }

      function lerpWrapped(start, end, progress, maxValue) {
        let diff = end - start;

        // Handle wrap-around by taking the shortest path
        if (diff > maxValue * 0.5) {
          diff -= maxValue;
        } else if (diff < -maxValue * 0.5) {
          diff += maxValue;
        }

        let result = start + diff * progress;

        // Optimize modulo operations
        if (result < 0) result += maxValue;
        else if (result >= maxValue) result -= maxValue;

        return result;
      }

      function getInterpolatedSnake() {
        // Cache interpolated positions to avoid recalculation
        if (
          moveProgress === lastMoveProgress &&
          cachedInterpolatedSnake.length === snake.length
        ) {
          return cachedInterpolatedSnake;
        }

        // Reuse existing array if possible
        if (cachedInterpolatedSnake.length !== snake.length) {
          cachedInterpolatedSnake = new Array(snake.length);
        }

        for (let i = 0; i < snake.length; i++) {
          if (!cachedInterpolatedSnake[i]) {
            cachedInterpolatedSnake[i] = { x: 0, y: 0 };
          }

          if (i < prevSnake.length) {
            // Interpolate from previous position to current position with wrap-around
            cachedInterpolatedSnake[i].x = lerpWrapped(
              prevSnake[i].x,
              snake[i].x,
              moveProgress,
              tileCount,
            );
            cachedInterpolatedSnake[i].y = lerpWrapped(
              prevSnake[i].y,
              snake[i].y,
              moveProgress,
              tileCount,
            );
          } else {
            // New segment (snake grew), start from the last previous position
            const lastPrevPos = prevSnake[prevSnake.length - 1];
            cachedInterpolatedSnake[i].x = lerpWrapped(
              lastPrevPos.x,
              snake[i].x,
              moveProgress,
              tileCount,
            );
            cachedInterpolatedSnake[i].y = lerpWrapped(
              lastPrevPos.y,
              snake[i].y,
              moveProgress,
              tileCount,
            );
          }
        }

        lastMoveProgress = moveProgress;
        return cachedInterpolatedSnake;
      }

      function drawGame() {
        // Clear canvas once
        ctx.fillStyle = "#0a0a0a";
        ctx.fillRect(0, 0, canvasSize, canvasSize);

        const displaySnake = getInterpolatedSnake();

        // Batch snake body drawing to minimize state changes
        if (displaySnake.length > 1) {
          ctx.fillStyle = "#2ecc71";

          // Draw all body segments first
          for (let i = 1; i < displaySnake.length; i++) {
            const segment = displaySnake[i];
            const segmentX = segment.x * gridSize;
            const segmentY = segment.y * gridSize;

            ctx.beginPath();
            ctx.roundRect(
              segmentX + 2,
              segmentY + 2,
              gridSize - 4,
              gridSize - 4,
              8,
            );
            ctx.fill();
          }

          // Draw all highlights in one batch
          ctx.fillStyle = "#58d68d";
          for (let i = 1; i < displaySnake.length; i++) {
            const segment = displaySnake[i];
            const segmentX = segment.x * gridSize;
            const segmentY = segment.y * gridSize;

            ctx.beginPath();
            ctx.roundRect(
              segmentX + 5,
              segmentY + 5,
              gridSize - 10,
              gridSize - 10,
              6,
            );
            ctx.fill();
          }
        }

        // Draw snake head (optimized eye positioning)
        if (displaySnake.length > 0) {
          const head = displaySnake[0];
          const headX = head.x * gridSize;
          const headY = head.y * gridSize;

          // Head base
          ctx.fillStyle = "#27ae60";
          ctx.beginPath();
          ctx.roundRect(headX + 1, headY + 1, gridSize - 2, gridSize - 2, 6);
          ctx.fill();

          // Head highlight
          ctx.fillStyle = "#58d68d";
          ctx.beginPath();
          ctx.roundRect(headX + 4, headY + 4, gridSize - 8, gridSize - 8, 4);
          ctx.fill();

          // Optimize eye positioning with lookup table
          let eyeOffsets;
          if (dx === 1)
            eyeOffsets = [
              [gridSize - 8, 6],
              [gridSize - 8, gridSize - 12],
            ];
          else if (dx === -1)
            eyeOffsets = [
              [4, 6],
              [4, gridSize - 12],
            ];
          else if (dy === 1)
            eyeOffsets = [
              [6, gridSize - 8],
              [gridSize - 12, gridSize - 8],
            ];
          else if (dy === -1)
            eyeOffsets = [
              [6, 4],
              [gridSize - 12, 4],
            ];
          else
            eyeOffsets = [
              [gridSize - 8, 6],
              [gridSize - 8, gridSize - 12],
            ]; // default right

          // Draw eyes efficiently
          ctx.fillStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(
            headX + eyeOffsets[0][0],
            headY + eyeOffsets[0][1],
            3,
            0,
            6.283185307179586,
          );
          ctx.arc(
            headX + eyeOffsets[1][0],
            headY + eyeOffsets[1][1],
            3,
            0,
            6.283185307179586,
          );
          ctx.fill();

          // Draw pupils
          ctx.fillStyle = "#000000";
          ctx.beginPath();
          ctx.arc(
            headX + eyeOffsets[0][0],
            headY + eyeOffsets[0][1],
            1.5,
            0,
            6.283185307179586,
          );
          ctx.arc(
            headX + eyeOffsets[1][0],
            headY + eyeOffsets[1][1],
            1.5,
            0,
            6.283185307179586,
          );
          ctx.fill();

          // Draw tongue efficiently
          ctx.strokeStyle = "#e74c3c";
          ctx.lineWidth = 2;
          ctx.beginPath();

          const centerX = headX + gridSize * 0.5;
          const centerY = headY + gridSize * 0.5;

          if (dx === 1) {
            ctx.moveTo(headX + gridSize, centerY);
            ctx.lineTo(headX + gridSize + 6, centerY - 2);
            ctx.moveTo(headX + gridSize, centerY);
            ctx.lineTo(headX + gridSize + 6, centerY + 2);
          } else if (dx === -1) {
            ctx.moveTo(headX, centerY);
            ctx.lineTo(headX - 6, centerY - 2);
            ctx.moveTo(headX, centerY);
            ctx.lineTo(headX - 6, centerY + 2);
          } else if (dy === 1) {
            ctx.moveTo(centerX, headY + gridSize);
            ctx.lineTo(centerX - 2, headY + gridSize + 6);
            ctx.moveTo(centerX, headY + gridSize);
            ctx.lineTo(centerX + 2, headY + gridSize + 6);
          } else if (dy === -1) {
            ctx.moveTo(centerX, headY);
            ctx.lineTo(centerX - 2, headY - 6);
            ctx.moveTo(centerX, headY);
            ctx.lineTo(centerX + 2, headY - 6);
          }
          ctx.stroke();
        }

        // Draw food
        ctx.fillStyle = "#e74c3c";
        ctx.beginPath();
        ctx.arc(
          food.x * gridSize + gridSize * 0.5,
          food.y * gridSize + gridSize * 0.5,
          gridSize * 0.5 - 2,
          0,
          6.283185307179586,
        );
        ctx.fill();

        // Food shine
        ctx.fillStyle = "#ff6b6b";
        ctx.beginPath();
        ctx.arc(
          food.x * gridSize + gridSize * 0.5 - 5,
          food.y * gridSize + gridSize * 0.5 - 5,
          5,
          0,
          6.283185307179586,
        );
        ctx.fill();

        // Batch wall drawing
        if (walls.length > 0) {
          ctx.fillStyle = "#95a5a6";
          for (let i = 0; i < walls.length; i++) {
            const wall = walls[i];
            const wallX = wall.x * gridSize;
            const wallY = wall.y * gridSize;
            ctx.fillRect(wallX, wallY, gridSize, gridSize);
          }

          ctx.fillStyle = "#7f8c8d";
          for (let i = 0; i < walls.length; i++) {
            const wall = walls[i];
            const wallX = wall.x * gridSize;
            const wallY = wall.y * gridSize;
            ctx.fillRect(wallX + 2, wallY + 2, gridSize - 4, gridSize - 4);
          }

          ctx.fillStyle = "#bdc3c7";
          for (let i = 0; i < walls.length; i++) {
            const wall = walls[i];
            const wallX = wall.x * gridSize;
            const wallY = wall.y * gridSize;
            ctx.fillRect(wallX + 4, wallY + 4, gridSize - 8, gridSize - 8);
          }
        }
      }

      function moveSnake() {
        if (dx === 0 && dy === 0) return; // Don't move if no direction set

        const head = { x: snake[0].x + dx, y: snake[0].y + dy };

        // Wrap around the board
        if (head.x < 0) {
          head.x = tileCount - 1;
        } else if (head.x >= tileCount) {
          head.x = 0;
        }

        if (head.y < 0) {
          head.y = tileCount - 1;
        } else if (head.y >= tileCount) {
          head.y = 0;
        }

        snake.unshift(head);

        // Check if food eaten
        if (head.x === food.x && head.y === food.y) {
          score += 10;
          scoreElement.textContent = score;

          // Update speed display
          const currentSpeed = getCurrentMoveInterval();
          const speedPercent = Math.round(
            ((baseInterval - currentSpeed) / (baseInterval - minInterval)) *
              100,
          );
          statusElement.textContent = `Speed: ${speedPercent}%`;

          randomFoodPosition();
        } else {
          snake.pop();
        }
      }

      function checkCollision() {
        const headX = snake[0].x;
        const headY = snake[0].y;

        // Check self collision (optimized with early exit)
        for (let i = 1; i < snake.length; i++) {
          if (snake[i].x === headX && snake[i].y === headY) {
            return true;
          }
        }

        // Check wall collision (optimized with early exit)
        for (let i = 0; i < walls.length; i++) {
          if (walls[i].x === headX && walls[i].y === headY) {
            return true;
          }
        }

        return false;
      }

      function gameLoop(currentTime) {
        if (!gameRunning) return;

        const currentMoveInterval = getCurrentMoveInterval();
        const elapsed = currentTime - lastMoveTime;

        // Calculate time since last move
        if (elapsed >= currentMoveInterval) {
          dx = dx_next;
          dy = dy_next;
          // Store previous positions before moving (reuse array if possible)
          if (prevSnake.length !== snake.length) {
            prevSnake = new Array(snake.length);
          }
          for (let i = 0; i < snake.length; i++) {
            if (!prevSnake[i]) prevSnake[i] = { x: 0, y: 0 };
            prevSnake[i].x = snake[i].x;
            prevSnake[i].y = snake[i].y;
          }

          moveSnake();

          if (checkCollision()) {
            gameRunning = false;
            setTimeout(() => {
              startGame();
            }, 2000);
            return;
          }

          lastMoveTime = currentTime;
          moveProgress = 0;
        } else {
          // Use consistent progress calculation to avoid timing issues
          moveProgress = Math.min(elapsed / currentMoveInterval, 1);
        }

        drawGame();
        requestAnimationFrame(gameLoop);
      }

      function startGame() {
        // Reset game state
        initializeSnakePosition();
        score = 0;
        scoreElement.textContent = score;
        statusElement.textContent = "Speed: 0%";
        gameRunning = true;
        moveProgress = 1; // Start with completed move to avoid initial animation
        lastMoveTime = 0;

        // Clear performance caches
        cachedInterpolatedSnake = [];
        lastMoveProgress = -1;

        generateWalls();
        randomFoodPosition();
        requestAnimationFrame(gameLoop);
      }

      // Handle window resize
      function handleResize() {
        calculateGameDimensions();
        if (gameRunning) {
          // Restart game on resize to avoid positioning issues
          startGame();
        } else {
          drawGame();
        }
      }

      window.addEventListener("resize", handleResize);
      window.addEventListener("orientationchange", () => {
        setTimeout(handleResize, 100); // Delay for orientation change
      });

      // Touch event handlers for swipe detection
      canvas.addEventListener("touchstart", handleTouchStart, false);
      canvas.addEventListener("touchend", handleTouchEnd, false);

      function handleTouchStart(e) {
        e.preventDefault();
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;
      }

      function handleTouchEnd(e) {
        e.preventDefault();
        if (!gameRunning) return;

        const touch = e.changedTouches[0];
        endX = touch.clientX;
        endY = touch.clientY;

        const deltaX = endX - startX;
        const deltaY = endY - startY;

        // Minimum swipe distance
        const minSwipeDistance = 30;

        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          // Horizontal swipe
          if (Math.abs(deltaX) > minSwipeDistance) {
            if (deltaX > 0 && dx !== -1) {
              // Swipe right
              dx_next = 1;
              dy_next = 0;
            } else if (deltaX < 0 && dx !== 1) {
              // Swipe left
              dx_next = -1;
              dy_next = 0;
            }
          }
        } else {
          // Vertical swipe
          if (Math.abs(deltaY) > minSwipeDistance) {
            if (deltaY > 0 && dy !== -1) {
              // Swipe down
              dx_next = 0;
              dy_next = 1;
            } else if (deltaY < 0 && dy !== 1) {
              // Swipe up
              dx_next = 0;
              dy_next = -1;
            }
          }
        }
      }

      // Keyboard controls as backup
      document.addEventListener("keydown", (e) => {
        if (!gameRunning) return;

        switch (e.key) {
          case "ArrowUp":
            if (dy !== 1) {
              dx_next = 0;
              dy_next = -1;
            }
            break;
          case "ArrowDown":
            if (dy !== -1) {
              dx_next = 0;
              dy_next = 1;
            }
            break;
          case "ArrowLeft":
            if (dx !== 1) {
              dx_next = -1;
              dy_next = 0;
            }
            break;
          case "ArrowRight":
            if (dx !== -1) {
              dx_next = 1;
              dy_next = 0;
            }
            break;
        }
      });

      // Initialize the game
      calculateGameDimensions();
      startGame();
    </script>
  </body>
</html>
